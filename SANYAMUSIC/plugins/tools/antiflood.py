import asyncio
import time
from typing import Dict, Tuple, Optional

from pyrogram import filters
from pyrogram.types import Message, ChatPermissions
from pyrogram.enums import ChatMemberStatus
from SANYAMUSIC import app
from motor.motor_asyncio import AsyncIOMotorClient
from config import COMMAND_PREFIXES, MONGO_DB_URI

mongo = AsyncIOMotorClient(MONGO_DB_URI)
flood_col = mongo.SANYAMUSIC["antiflood"]

user_flood_tracker: Dict[Tuple[int, int], Dict[str, float]] = {}
tracker_lock = asyncio.Lock()

DEFAULT_LIMIT = 7
DEFAULT_ACTION = "mute"
CLEANUP_INTERVAL = 60          # seconds — background cleanup frequency
MAX_RETENTION = 3600           # seconds — keep entries at most this long

async def get_flood_settings(chat_id: int) -> dict:
    data = await flood_col.find_one({"chat_id": chat_id})
    if not data:
        return {
            "limit": DEFAULT_LIMIT,
            "action": DEFAULT_ACTION,
            "timer": None,
            "clear": False,
            "duration": None,
        }
    return data


async def set_flood_settings(chat_id: int, updates: dict):
    await flood_col.update_one({"chat_id": chat_id}, {"$set": updates}, upsert=True)


async def is_admin(chat_id: int, user_id: int) -> bool:
    try:
        member = await app.get_chat_member(chat_id, user_id)
        if member.status in (ChatMemberStatus.OWNER, ChatMemberStatus.ADMINISTRATOR):
            return True
        if getattr(member, "privileges", None):
            priv = member.privileges
            return any([
                getattr(priv, "can_delete_messages", False),
                getattr(priv, "can_manage_chat", False),
                getattr(priv, "can_restrict_members", False),
                getattr(priv, "can_promote_members", False)
            ])
    except Exception:
        pass
    return False


def parse_time(duration: Optional[str]) -> Optional[int]:
    """
    Parse strings like '10s', '5m', '2h', '1d' into seconds.
    Returns None for invalid or None input.
    """
    if not duration:
        return None
    try:
        s = duration.strip().lower()
        num = int("".join([c for c in s if c.isdigit()]) or 0)
        if num <= 0:
            return None
        if "d" in s:
            return num * 86400
        if "h" in s:
            return num * 3600
        if "m" in s:
            return num * 60
        if "s" in s:
            return num

        return num
    except Exception:
        return None


@app.on_message(filters.command("flood", prefixes=COMMAND_PREFIXES) & filters.group)
async def flood_status(_, m: Message):
    settings = await get_flood_settings(m.chat.id)
    txt = (
        "╭─⎯⎯⎯⎯  ᴀɴᴛɪғʟᴏᴏᴅ sᴇᴛᴛɪɴɢs  ⎯⎯⎯╮\n\n"
        f"• ʟɪᴍɪᴛ     : `{settings.get('limit')}` ᴍsɢs\n"
        f"• ᴀᴄᴛɪᴏɴ   : `{settings.get('action')}`\n"
        f"• ᴅᴜʀᴀᴛɪᴏɴ : `{settings.get('duration') or 'ᴅᴇғᴀᴜʟᴛ'}`\n"
        f"• ᴛɪᴍᴇʀ   : `{settings.get('timer') or 'ᴅɪsᴀʙʟᴇᴅ'}`\n"
        f"• ᴄʟᴇᴀʀ   : `{settings.get('clear')}`\n\n"
        "╰──────────────────────────────────╯"
    )
    await m.reply_text(txt)


@app.on_message(filters.command("setflood", prefixes=COMMAND_PREFIXES) & filters.group)
async def set_flood_limit(_, m: Message):
    if not await is_admin(m.chat.id, m.from_user.id):
        return await m.reply_text(" ᴏɴʟʏ ᴀᴅᴍɪɴs ᴄᴀɴ ᴜsᴇ ᴛʜɪs ᴄᴏᴍᴍᴀɴᴅ.")
    if len(m.command) < 2:
        return await m.reply_text("ᴜsᴀɢᴇ: `/setflood <ɴᴜᴍʙᴇʀ|ᴏғғ>`")

    arg = m.command[1].lower()
    if arg in ["off", "no", "0"]:
        await set_flood_settings(m.chat.id, {"limit": 0})
        return await m.reply_text(" ᴀɴᴛɪғʟᴏᴏᴅ ᴅɪsᴀʙʟᴇᴅ.")

    try:
        limit = int(arg)
        if limit < 2:
            raise ValueError
    except ValueError:
        return await m.reply_text(" ɪɴᴠᴀʟɪᴅ ᴠᴀʟᴜᴇ.")

    await set_flood_settings(m.chat.id, {"limit": limit})
    await m.reply_text(f" ᴀɴᴛɪғʟᴏᴏᴅ ᴛʀɪɢɢᴇʀ ᴀғᴛᴇʀ `{limit}` ᴍᴇssᴀɢᴇs.")


@app.on_message(filters.command(["setfloodmode", "floodmode"], prefixes=COMMAND_PREFIXES) & filters.group)
async def set_flood_action(_, m: Message):
    if not await is_admin(m.chat.id, m.from_user.id):
        return await m.reply_text(" ᴏɴʟʏ ᴀᴅᴍɪɴs ᴄᴀɴ ᴜsᴇ ᴛʜɪs ᴄᴏᴍᴍᴀɴᴅ.")
    if len(m.command) < 2:
        return await m.reply_text("ᴜsᴀɢᴇ: `/setfloodmode <ʙᴀɴ/ᴍᴜᴛᴇ/ᴋɪᴄᴋ/ᴛʙᴀɴ/ᴛᴍᴜᴛᴇ> [ᴅᴜʀᴀᴛɪᴏɴ]`")

    action = m.command[1].lower()
    if action not in ["ban", "mute", "kick", "tban", "tmute"]:
        return await m.reply_text(" ɪɴᴠᴀʟɪᴅ ᴀᴄᴛɪᴏɴ.")

    duration = m.command[2] if len(m.command) >= 3 else None
    if action in ["tban", "tmute"] and not parse_time(duration):
        return await m.reply_text(" ᴘʟᴇᴀsᴇ ɢɪᴠᴇ ᴠᴀʟɪᴅ ᴅᴜʀᴀᴛɪᴏɴ (e.g. 30s, 5m, 2h).")

    await set_flood_settings(m.chat.id, {"action": action, "duration": duration})
    await m.reply_text(f" ᴀᴄᴛɪᴏɴ sᴇᴛ ᴛᴏ `{action}` {duration or ''}.")


@app.on_message(filters.command("setfloodtimer", prefixes=COMMAND_PREFIXES) & filters.group)
async def set_flood_timer(_, m: Message):
    if not await is_admin(m.chat.id, m.from_user.id):
        return await m.reply_text(" ᴏɴʟʏ ᴀᴅᴍɪɴs ᴄᴀɴ ᴜsᴇ ᴛʜɪs ᴄᴏᴍᴍᴀɴᴅ.")
    if len(m.command) < 3:
        return await m.reply_text("ᴜsᴀɢᴇ: `/setfloodtimer <ᴍsɢs> <ᴛɪᴍᴇ>`")

    if m.command[1].lower() in ["off", "no"]:
        await set_flood_settings(m.chat.id, {"timer": None})
        return await m.reply_text(" ᴛɪᴍᴇᴅ ᴀɴᴛɪғʟᴏᴏᴅ ᴅɪsᴀʙʟᴇᴅ.")

    try:
        msgs = int(m.command[1])
        secs = parse_time(m.command[2])
        if msgs < 1 or not secs:
            raise ValueError
    except Exception:
        return await m.reply_text(" ɪɴᴠᴀʟɪᴅ ғᴏʀᴍᴀᴛ. ᴇx: `/setfloodtimer 10 30s`")

    await set_flood_settings(m.chat.id, {"timer": {"messages": msgs, "seconds": secs}})
    await m.reply_text(f" ᴛɪᴍᴇᴅ ᴀɴᴛɪғʟᴏᴏᴅ: `{msgs}` ᴍsɢs / `{secs}s`.")


@app.on_message(filters.command("clearflood", prefixes=COMMAND_PREFIXES) & filters.group)
async def clear_flood_msgs(_, m: Message):
    if not await is_admin(m.chat.id, m.from_user.id):
        return await m.reply_text(" ᴏɴʟʏ ᴀᴅᴍɪɴs ᴄᴀɴ ᴜsᴇ ᴛʜɪs ᴄᴏᴍᴍᴀɴᴅ.")
    if len(m.command) < 2:
        return await m.reply_text("ᴜsᴀɢᴇ: `/clearflood on|off`")

    arg = m.command[1].lower()
    state = arg in ["on", "yes", "true"]
    await set_flood_settings(m.chat.id, {"clear": state})
    await m.reply_text(f" ᴄʟᴇᴀʀ ғʟᴏᴏᴅ ᴍᴇssᴀɢᴇs: `{state}`")


@app.on_message(filters.group & ~filters.service & ~filters.bot)
async def flood_handler(_, message: Message):
    if not message.from_user:
        return

    chat_id = message.chat.id
    user_id = message.from_user.id
    now = time.time()

    settings = await get_flood_settings(chat_id)
    limit = settings.get("limit", DEFAULT_LIMIT)
    if not limit or limit <= 0:
        return

    # Skip admins
    if await is_admin(chat_id, user_id):
        return

    key = (chat_id, user_id)
    timer = settings.get("timer")

    async with tracker_lock:
        entry = user_flood_tracker.get(key)
        if not entry:
            user_flood_tracker[key] = {"count": 1, "time": now}
            return
        entry["count"] += 1
        if timer:
            msgs = timer.get("messages")
            secs = timer.get("seconds")
            if not msgs or not secs:
                if entry["count"] >= limit:
                    await take_action(message, settings)
                    user_flood_tracker.pop(key, None)
                return

            if now - entry["time"] <= secs and entry["count"] >= msgs:
                await take_action(message, settings)
                user_flood_tracker.pop(key, None)
            elif now - entry["time"] > secs:
                user_flood_tracker[key] = {"count": 1, "time": now}
        else:
            if entry["count"] >= limit:
                await take_action(message, settings)
                user_flood_tracker.pop(key, None)


async def take_action(message: Message, settings: dict):
    chat_id = message.chat.id
    user = message.from_user
    action = settings.get("action", "mute")
    duration = settings.get("duration")
    clear = settings.get("clear", False)

    try:
        if clear:
            try:
                await message.delete()
            except Exception:
                pass

        if action == "ban":
            await app.ban_chat_member(chat_id, user.id)
            await message.reply_text(f" {user.mention} ʙᴀɴɴᴇᴅ ғᴏʀ ғʟᴏᴏᴅɪɴɢ.")
        elif action == "mute":
            perms = ChatPermissions(can_send_messages=False)
            await app.restrict_chat_member(chat_id, user.id, permissions=perms)
            await message.reply_text(f" {user.mention} ᴍᴜᴛᴇᴅ ғᴏʀ ғʟᴏᴏᴅɪɴɢ.")
        elif action == "kick":
            await app.ban_chat_member(chat_id, user.id)
            await app.unban_chat_member(chat_id, user.id)
            await message.reply_text(f" {user.mention} ᴋɪᴄᴋᴇᴅ ғᴏʀ ғʟᴏᴏᴅɪɴɢ.")
        elif action in ["tban", "tmute"] and duration:
            seconds = parse_time(duration)
            if not seconds:
                await message.reply_text(" ɪɴᴠᴀʟɪᴅ ᴅᴜʀᴀᴛɪᴏɴ ᴄᴏɴꜰɪɢᴜʀᴇᴅ.")
                return
            until_date = int(time.time() + seconds)
            if action == "tban":
                await app.ban_chat_member(chat_id, user.id, until_date=until_date)
                await message.reply_text(f" {user.mention} ᴛᴇᴍᴘ ʙᴀɴɴᴇᴅ ғᴏʀ {duration}.")
            else:
                perms = ChatPermissions(can_send_messages=False)
                await app.restrict_chat_member(chat_id, user.id, permissions=perms, until_date=until_date)
                await message.reply_text(f" {user.mention} ᴛᴇᴍᴘ ᴍᴜᴛᴇᴅ ғᴏʀ {duration}.")
    except Exception as e:
        print("[antiflood] action error:", repr(e))


async def _cleanup_tracker():
    while True:
        await asyncio.sleep(CLEANUP_INTERVAL)
        cutoff = time.time() - MAX_RETENTION
        async with tracker_lock:
            keys_to_pop = [k for k, v in user_flood_tracker.items() if v.get("time", 0) < cutoff]
            for k in keys_to_pop:
                user_flood_tracker.pop(k, None)


asyncio.get_event_loop().create_task(_cleanup_tracker())
